{
  "title": "Spring的事务管理",
  "slug": "Spring的事务管理",
  "date": "2025-10-20",
  "tags": [
    "Spring"
  ],
  "cover": "",
  "summary": "",
  "content": "# 什么是事务？\n\n理解事务最简单的例子就是“银行转账”：\n\n**A 给 B 转账 100 元。**\n这个操作包含两步：A 账户扣 100 元，B 账户加 100 元。\n\n```mermaid\nsequenceDiagram\n    participant A as A 账户\n    participant Bank as 银行系统\n    participant B as B 账户\n\n    Note over A,B: A 要给 B 转账 100 元\n\n    A->>Bank: 请求转账 100 元\n    Bank->>A: 第一步：从 A 账户扣款 100 元\n    Note right of A: A 账户余额 -100 ✅\n\n    Bank->>B: 第二步：向 B 账户加款 100 元\n    Note left of B: ❌ 系统突然崩溃！\n    B-->>Bank: 加款失败！\n\n    Note over Bank: 🚨 问题出现！\n    Note over Bank: A 的钱被扣了，B 没收到。\n    Note over Bank: 100 元凭空消失了！\n\n```\n\n从上图可以看到第一步成功，第二步失败了，导致（钱丢了！）\n\n所以就有了事务的第一个概念：**事务就是要把这一系列操作捆绑成一个“原子操作”，要么都成功，要么都失败**\n\n ## 事务有4大特性（ACID)\n \n- **原子性:** 整个转账是一个不可分割的整体。\n- **一致性:** 转账前后，银行系统的总金额是不变的。\n- **隔离性:** A 和 C 同时给 B 转账，互相之间不能干扰。\n- **持久性:** 一旦转账成功，数据就永久保存了。\n\n**为什么需要 Spring 事务？** Spring提供了一种优雅、声明式的方式来管理事务(也有编程式事务管理)，让我们不用手动编写 `Connection.commit()` 和 `Connection.rollback()` 等繁琐代码。\n\n\n# Spring的声明式事务 `@Transactional` \n\n@Transactional是Spring 事务最核心、最常用的用法，例如你正在开发一个电商系统的核心功能——创建订单。这个操作包含两个密不可分的步骤：\n\n1. 在订单表里插入一条新订单记录。\n2. 在商品表里扣减对应商品的库存。\n\n这两个动作必须是一个“整体”，要么**都成功**，要么**都失败**。如果订单插入了，但库存没减，那用户就“凭空”买到了一个不存在的商品。这就是我们常说的“事务”。\n\n现在我们就通过 `@Transactional` 注解解决这个问题的。\n\n## 创建订单的业务逻辑\n\n我们先来创建一个简单的 `OrderService`，它负责处理创建订单的业务逻辑。\n```java\n// OrderService.java\n@Service\npublic class OrderService {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate; // Spring 提供的数据库操作工具\n\n    public void createOrder(String productId, int amount) {\n        // 1. 插入订单记录\n        String sql1 = \"INSERT INTO orders (product_id, amount) VALUES (?, ?)\";\n        jdbcTemplate.update(sql1, productId, amount);\n        \n        System.out.println(\"✅ 订单插入成功！\");\n\n        // 2. 扣减库存\n        String sql2 = \"UPDATE products SET stock = stock - ? WHERE id = ?\";\n        jdbcTemplate.update(sql2, amount, productId);\n        \n        System.out.println(\"✅ 库存扣减成功！\");\n    }\n}\n```\n\n## 对比：没有 `@Transactional` \n\n现在我们在 `createOrder` 方法里模拟一个意外。比如，在两个数据库操作之间，程序因为某个逻辑错误抛出了异常。\n\n```java\n// OrderService.java (不加 @Transactional)\n@Service\npublic class OrderService {\n\n    // ... JdbcTemplate 注入 ...\n\n    public void createOrder(String productId, int amount) {\n        // 1. 插入订单记录\n        String sql1 = \"INSERT INTO orders (product_id, amount) VALUES (?, ?)\";\n        jdbcTemplate.update(sql1, productId, amount);\n        System.out.println(\"✅ 订单插入成功！\");\n\n        // 模拟一个运行时异常！\n        System.out.println(\"💥 哎呀，程序出错了！\");\n        int i = 1 / 0; \n\n        // 2. 扣减库存 (这行代码永远不会被执行)\n        String sql2 = \"UPDATE products SET stock = stock - ? WHERE id = ?\";\n        jdbcTemplate.update(sql2, amount, productId);\n        System.out.println(\"✅ 库存扣减成功！\");\n    }\n}\n```\n\n**运行结果会怎样？**\n\n程序会因为 `1/0` 而崩溃，抛出 `ArithmeticException`。但此刻，数据库里发生了什么？\n\n- **`orders` 表**：多了一条新的订单记录。\n- **`products` 表**：库存完全没有变化。\n\n**数据不一致了！** 这正是我们不愿看到的最坏情况。\n\n## 使用`@Transactional` \n现在我们使用`@Transactional` \n```java\n// OrderService.java (加上 @Transactional)\n@Service\npublic class OrderService {\n\n    // ... JdbcTemplate 注入 ...\n\n    @Transactional // 看这里！只加了这一行！\n    public void createOrder(String productId, int amount) {\n        // 1. 插入订单记录\n        String sql1 = \"INSERT INTO orders (product_id, amount) VALUES (?, ?)\";\n        jdbcTemplate.update(sql1, productId, amount);\n        System.out.println(\"✅ 订单插入成功！\");\n\n        // 模拟一个运行时异常！\n        System.out.println(\"💥 哎呀，程序出错了！\");\n        int i = 1 / 0; \n\n        // 2. 扣减库存\n        String sql2 = \"UPDATE products SET stock = stock - ? WHERE id = ?\";\n        jdbcTemplate.update(sql2, amount, productId);\n        System.out.println(\"✅ 库存扣减成功！\");\n    }\n}\n\n```\n**再次运行，观察数据库结果：**\n\n程序同样会因为 `1/0` 而崩溃。但这一次，当我们去检查数据库时，会惊奇地发现：\n\n- **`orders` 表**：干干净净，什么都没有。\n- **`products` 表**：库存也丝毫未动。\n\n**数据库回到了调用方法之前的状态！**，`@Transactional` 通过AOP（面向切面编程）在方法执行前后自动开启和提交/回滚事务，确保了操作的原子性。\n\n# 深入理解`@Transactional` 的核心属性\n\n经过上面的例子我们已经了解到了@Transactional用法，下面介绍它的几个核心属性。\n\n## 属性一 propagation——传播行为\n\n**`propagation`（传播行为）** 定义了一个事务方法被另一个事务方法调用时，应该如何“社交”。它决定了当前事务是应该加入已有的“派对”，还是自己开一个“新派对”，甚至拒绝加入任何派对。\n\n这是 `@Transactional` 中最复杂也最重要的属性，我们用场景来理解最关键的几种：\n\n### **1. `PROPAGATION_REQUIRED` (默认值) —— “随大流”**\n\n- **场景：** 假设你在一个 `团购群`（外部事务）里，现在要发起一个 `拼单`（内部事务）。\n- **行为：** 如果 `团购群` 存在，你的 `拼单` 就直接加入这个群，大家一起成功，一起失败。如果 `团购群` 不存在，你的 `拼单` 就会自己创建一个新群。\n\n- **一句话总结：** 有我就加入，没我就新建。这是最常用的传播行为，能满足 80% 的业务需求。\n\n### 2. PROPAGATION_REQUIRES_NEW —— “特立独行”\n\n- **场景：** 你在处理一个 `核心业务`（如用户下单），同时需要记录一份 `操作日志`。你希望无论下单成功与否，日志都必须成功记录。\n- **行为：** `REQUIRES_NEW` 会为 `createLog` 方法**挂起**当前事务（核心业务），然后**开启一个全新的、独立的事务**。新事务提交或回滚后，再恢复挂起的旧事务。两者之间没有任何关系。\n\n一句话总结： 我总要开新派对，不管你有没有派对。适用于与主业务解耦的辅助功能，如日志、邮件通知。\n\n### **3. `PROPAGATION_NESTED` —— “子母事务”**\n\n- **场景：** 你在一个 `银行转账`（主事务）中，除了要扣减 A 账户、增加 B 账户外，还要进行一笔 `小额手续费` 的扣除。你希望手续费扣除失败可以回滚，但不影响转账主流程的成功。\n- **行为：** `NESTED` 会在当前事务中设置一个**保存点**。如果嵌套事务失败，它会回滚到这个保存点，而不是回滚整个事务。如果主事务失败，那么所有嵌套事务都会一起回滚。\n\n- **与 `REQUIRES_NEW` 的区别：**\n    - `REQUIRES_NEW` 是两个完全独立的事务，像两个独立的银行账户。\n    - `NESTED` 是一个事务内的部分回滚，像一个大账户里的多个子记账，可以单独撤销某个子记账。\n- **注意：** `NESTED` 依赖于底层数据库对保存点的支持（如 JDBC 的 `Savepoint`）\n\n## 属性二：`isolation` —— 隔离级别\n\n**`isolation`（隔离级别）** 定义了多个并发事务之间的“社交距离”，以防止它们互相干扰导致数据错乱。它直接对应数据库的隔离级别。\n\n- **`Isolation.READ_UNCOMMITTED` (读未提交)：** 能读到别人还没提交的“脏数据”。（几乎不用）\n- **`Isolation.READ_COMMITTED` (读已提交)：** 只读取别人已经提交的数据。可以避免脏读，但可能出现“不可重复读”。\n- **`Isolation.REPEATABLE_READ` (可重复读)：** 在同一个事务内多次读取同一数据，结果总是一样。可以避免脏读和不可重复读，但可能出现“幻读”。（**MySQL 默认级别**）\n- **`Isolation.SERIALIZABLE` (串行化)：** 所有事务按顺序排队执行，完全隔离。性能最低。\n\n> 99% 的情况下，使用数据库的默认隔离级别就足够了。不要随意修改，除非你非常清楚自己在做什么，以及为什么需要这么做。\n\n\n## 属性三：readOnly —— 只读模式\n\n- **作用：** 告诉 Spring：“这个方法只负责查询数据，绝不修改任何数据”。\n- **好处：**\n    1. **性能优化：** Spring 会据此优化数据库连接。比如，可能会将事务设置为只读，让数据库驱动可以进行一些特定的优化。\n    2. **代码清晰：** 这是一个非常明确的信号，告诉所有开发者这个方法的意图是查询。\n    \n## 属性四：`rollbackFor` & `noRollbackFor` —— 异常回滚\n\nSpring 默认的回滚策略可能和你想的并不一样。\n\n- **痛点引入：** “我的方法里抛了异常，为什么数据没有回滚？！”\n- **Spring 默认规则：** Spring 认为，只有不可预期的运行时异常（`RuntimeException`）或错误（`Error`）才应该触发回滚。对于那些可以预期的、在编译期就需要处理的**受检异常**（Checked Exception，如 `IOException`, `SQLException`），它默认不回滚。\n    \n    - 为什么这么设计？因为 Spring 的设计者认为，受检异常通常是业务逻辑的一部分，你可能希望在代码中捕获并处理它，而不是直接让整个事务失败。\n    \n- **`rollbackFor` (回滚白名单)：** 指定哪些异常需要回滚。\n\n```java\n// 当抛出任何 Exception (包括受检异常) 时都回滚\n@Transactional(rollbackFor = Exception.class)\npublic void methodWithCheckedException() throws IOException {\n    // ... 业务逻辑 ...\n    throw new IOException(\"文件操作失败\"); // 现在事务会回滚\n}\n```\n- **`noRollbackFor` (回滚黑名单)：** 指定哪些异常**不**需要回滚。\n```java\n// 即使是 RuntimeException，指定了也不回滚\n@Transactional(noRollbackFor = IllegalArgumentException.class)\npublic void methodWithSpecificException() {\n    throw new IllegalArgumentException(\"参数非法\"); // 事务不会回滚\n}\n```\n\n\n--- \n\n# 常见的“事务失效”问题\n\n1. 方法权限问题。`@Transactional` 只能用于 `public` 方法。\n2. `self-invocation`（自调用）问题。** （**重点！**）\n\t- **场景：** 一个类中的 `methodA`（无注解）调用了同一个类中的 `methodB`（有 `@Transactional` 注解）。\n\t- **原因：** Spring AOP 是通过代理实现的。`methodA` 内部调用 `methodB` 时，走的是 `this` 引用，而不是代理对象，因此事务切面不会生效。\n\t- **解决方案：** （1）注入自己；（2）通过 `AopContext` 获取代理对象；（3）将 `methodB` 移到另一个 Service 中。\n3. 异常被 `try-catch` “吃掉”了。**\n\t- **场景：** 在事务方法内部 `try-catch` 了异常，但没有在 `catch` 块中重新抛出。\n\t- **原因：** AOP 代理捕获不到异常，认为方法正常执行完毕，于是提交事务。\n\t- **解决方案：** 在 `catch` 中 `throw new RuntimeException();` 或手动设置事务状态 `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();`。\n4. 事务传播行为配置错误。** （回顾第三关的  `propagation`）\n\n---\n\n# Spring编程式事务\n\n当声明式事务无法满足复杂业务逻辑时，编程式事务成为必要选择。包括：\n\n- 一个方法中需要多个独立事务（部分提交、部分回滚）\n- 需要根据运行时条件动态决定事务边界\n- 需要在事务中执行非事务性操作\n\n代码示例：\n```java\n@Service\npublic class OrderService {\n    \n    @Autowired\n    private TransactionTemplate transactionTemplate;\n    \n    public void placeOrder(Order order) {\n        // 第一个事务：创建订单\n        transactionTemplate.execute(status -> {\n            try {\n                orderRepository.save(order);\n                // 其他订单相关操作\n                return true;\n            } catch (Exception e) {\n                status.setRollbackOnly();\n                return false;\n            }\n        });\n        \n        // 第二个事务：扣减库存\n        transactionTemplate.execute(status -> {\n            try {\n                inventoryService.reduceStock(order.getProductId(), order.getQuantity());\n                return true;\n            } catch (InsufficientStockException e) {\n                status.setRollbackOnly();\n                // 可以在这里执行补偿逻辑\n                return false;\n            }\n        });\n    }\n}\n```\n\n 使用 PlatformTransactionManager（更底层的方式）\n```java\n@Service\npublic class PaymentService {\n    \n    @Autowired\n    private PlatformTransactionManager transactionManager;\n    \n    public void processPayment(Payment payment) {\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);\n        def.setTimeout(30); // 30秒超时\n        \n        TransactionStatus status = transactionManager.getTransaction(def);\n        \n        try {\n            paymentRepository.save(payment);\n            accountService.debit(payment.getAccountId(), payment.getAmount());\n            transactionManager.commit(status);\n        } catch (Exception e) {\n            transactionManager.rollback(status);\n            throw new PaymentException(\"Payment failed\", e);\n        }\n    }\n}\n\n```\n## 核心组件\n\nSpring 事务管理的三大核心接口：\n\n1. **PlatformTransactionManager**：事务管理器接口\n    - 负责事务的获取、提交和回滚\n    - 常见实现：`DataSourceTransactionManager`、`JpaTransactionManager`等\n2. **TransactionDefinition**：事务定义信息\n    - 定义事务的传播行为、隔离级别、超时时间、只读状态等\n    - 通过 `TransactionAttribute` 接口扩展\n3. **TransactionStatus**：事务状态\n    - 表示当前事务的状态（是否新事务、是否已完成、是否设置回滚等）\n    - 提供控制事务的方法（如 `setRollbackOnly()`）\n",
  "html": "<h1>什么是事务？</h1>\n<p>理解事务最简单的例子就是“银行转账”：</p>\n<p><strong>A 给 B 转账 100 元。</strong>\n这个操作包含两步：A 账户扣 100 元，B 账户加 100 元。</p>\n<pre><code class=\"language-mermaid\">sequenceDiagram\n    participant A as A 账户\n    participant Bank as 银行系统\n    participant B as B 账户\n\n    Note over A,B: A 要给 B 转账 100 元\n\n    A-&gt;&gt;Bank: 请求转账 100 元\n    Bank-&gt;&gt;A: 第一步：从 A 账户扣款 100 元\n    Note right of A: A 账户余额 -100 ✅\n\n    Bank-&gt;&gt;B: 第二步：向 B 账户加款 100 元\n    Note left of B: ❌ 系统突然崩溃！\n    B--&gt;&gt;Bank: 加款失败！\n\n    Note over Bank: 🚨 问题出现！\n    Note over Bank: A 的钱被扣了，B 没收到。\n    Note over Bank: 100 元凭空消失了！\n</code></pre>\n<p>从上图可以看到第一步成功，第二步失败了，导致（钱丢了！）</p>\n<p>所以就有了事务的第一个概念：<strong>事务就是要把这一系列操作捆绑成一个“原子操作”，要么都成功，要么都失败</strong></p>\n<h2>事务有4大特性（ACID)</h2>\n<ul>\n<li><strong>原子性:</strong> 整个转账是一个不可分割的整体。</li>\n<li><strong>一致性:</strong> 转账前后，银行系统的总金额是不变的。</li>\n<li><strong>隔离性:</strong> A 和 C 同时给 B 转账，互相之间不能干扰。</li>\n<li><strong>持久性:</strong> 一旦转账成功，数据就永久保存了。</li>\n</ul>\n<p><strong>为什么需要 Spring 事务？</strong> Spring提供了一种优雅、声明式的方式来管理事务(也有编程式事务管理)，让我们不用手动编写 <code>Connection.commit()</code> 和 <code>Connection.rollback()</code> 等繁琐代码。</p>\n<h1>Spring的声明式事务 <code>@Transactional</code></h1>\n<p>@Transactional是Spring 事务最核心、最常用的用法，例如你正在开发一个电商系统的核心功能——创建订单。这个操作包含两个密不可分的步骤：</p>\n<ol>\n<li>在订单表里插入一条新订单记录。</li>\n<li>在商品表里扣减对应商品的库存。</li>\n</ol>\n<p>这两个动作必须是一个“整体”，要么<strong>都成功</strong>，要么<strong>都失败</strong>。如果订单插入了，但库存没减，那用户就“凭空”买到了一个不存在的商品。这就是我们常说的“事务”。</p>\n<p>现在我们就通过 <code>@Transactional</code> 注解解决这个问题的。</p>\n<h2>创建订单的业务逻辑</h2>\n<p>我们先来创建一个简单的 <code>OrderService</code>，它负责处理创建订单的业务逻辑。</p>\n<pre><code class=\"language-java\">// OrderService.java\n@Service\npublic class OrderService {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate; // Spring 提供的数据库操作工具\n\n    public void createOrder(String productId, int amount) {\n        // 1. 插入订单记录\n        String sql1 = &quot;INSERT INTO orders (product_id, amount) VALUES (?, ?)&quot;;\n        jdbcTemplate.update(sql1, productId, amount);\n        \n        System.out.println(&quot;✅ 订单插入成功！&quot;);\n\n        // 2. 扣减库存\n        String sql2 = &quot;UPDATE products SET stock = stock - ? WHERE id = ?&quot;;\n        jdbcTemplate.update(sql2, amount, productId);\n        \n        System.out.println(&quot;✅ 库存扣减成功！&quot;);\n    }\n}\n</code></pre>\n<h2>对比：没有 <code>@Transactional</code></h2>\n<p>现在我们在 <code>createOrder</code> 方法里模拟一个意外。比如，在两个数据库操作之间，程序因为某个逻辑错误抛出了异常。</p>\n<pre><code class=\"language-java\">// OrderService.java (不加 @Transactional)\n@Service\npublic class OrderService {\n\n    // ... JdbcTemplate 注入 ...\n\n    public void createOrder(String productId, int amount) {\n        // 1. 插入订单记录\n        String sql1 = &quot;INSERT INTO orders (product_id, amount) VALUES (?, ?)&quot;;\n        jdbcTemplate.update(sql1, productId, amount);\n        System.out.println(&quot;✅ 订单插入成功！&quot;);\n\n        // 模拟一个运行时异常！\n        System.out.println(&quot;💥 哎呀，程序出错了！&quot;);\n        int i = 1 / 0; \n\n        // 2. 扣减库存 (这行代码永远不会被执行)\n        String sql2 = &quot;UPDATE products SET stock = stock - ? WHERE id = ?&quot;;\n        jdbcTemplate.update(sql2, amount, productId);\n        System.out.println(&quot;✅ 库存扣减成功！&quot;);\n    }\n}\n</code></pre>\n<p><strong>运行结果会怎样？</strong></p>\n<p>程序会因为 <code>1/0</code> 而崩溃，抛出 <code>ArithmeticException</code>。但此刻，数据库里发生了什么？</p>\n<ul>\n<li><strong><code>orders</code> 表</strong>：多了一条新的订单记录。</li>\n<li><strong><code>products</code> 表</strong>：库存完全没有变化。</li>\n</ul>\n<p><strong>数据不一致了！</strong> 这正是我们不愿看到的最坏情况。</p>\n<h2>使用<code>@Transactional</code></h2>\n<p>现在我们使用<code>@Transactional</code> </p>\n<pre><code class=\"language-java\">// OrderService.java (加上 @Transactional)\n@Service\npublic class OrderService {\n\n    // ... JdbcTemplate 注入 ...\n\n    @Transactional // 看这里！只加了这一行！\n    public void createOrder(String productId, int amount) {\n        // 1. 插入订单记录\n        String sql1 = &quot;INSERT INTO orders (product_id, amount) VALUES (?, ?)&quot;;\n        jdbcTemplate.update(sql1, productId, amount);\n        System.out.println(&quot;✅ 订单插入成功！&quot;);\n\n        // 模拟一个运行时异常！\n        System.out.println(&quot;💥 哎呀，程序出错了！&quot;);\n        int i = 1 / 0; \n\n        // 2. 扣减库存\n        String sql2 = &quot;UPDATE products SET stock = stock - ? WHERE id = ?&quot;;\n        jdbcTemplate.update(sql2, amount, productId);\n        System.out.println(&quot;✅ 库存扣减成功！&quot;);\n    }\n}\n</code></pre>\n<p><strong>再次运行，观察数据库结果：</strong></p>\n<p>程序同样会因为 <code>1/0</code> 而崩溃。但这一次，当我们去检查数据库时，会惊奇地发现：</p>\n<ul>\n<li><strong><code>orders</code> 表</strong>：干干净净，什么都没有。</li>\n<li><strong><code>products</code> 表</strong>：库存也丝毫未动。</li>\n</ul>\n<p><strong>数据库回到了调用方法之前的状态！</strong>，<code>@Transactional</code> 通过AOP（面向切面编程）在方法执行前后自动开启和提交/回滚事务，确保了操作的原子性。</p>\n<h1>深入理解<code>@Transactional</code> 的核心属性</h1>\n<p>经过上面的例子我们已经了解到了@Transactional用法，下面介绍它的几个核心属性。</p>\n<h2>属性一 propagation——传播行为</h2>\n<p><strong><code>propagation</code>（传播行为）</strong> 定义了一个事务方法被另一个事务方法调用时，应该如何“社交”。它决定了当前事务是应该加入已有的“派对”，还是自己开一个“新派对”，甚至拒绝加入任何派对。</p>\n<p>这是 <code>@Transactional</code> 中最复杂也最重要的属性，我们用场景来理解最关键的几种：</p>\n<h3><strong>1. <code>PROPAGATION_REQUIRED</code> (默认值) —— “随大流”</strong></h3>\n<ul>\n<li><p><strong>场景：</strong> 假设你在一个 <code>团购群</code>（外部事务）里，现在要发起一个 <code>拼单</code>（内部事务）。</p>\n</li>\n<li><p><strong>行为：</strong> 如果 <code>团购群</code> 存在，你的 <code>拼单</code> 就直接加入这个群，大家一起成功，一起失败。如果 <code>团购群</code> 不存在，你的 <code>拼单</code> 就会自己创建一个新群。</p>\n</li>\n<li><p><strong>一句话总结：</strong> 有我就加入，没我就新建。这是最常用的传播行为，能满足 80% 的业务需求。</p>\n</li>\n</ul>\n<h3>2. PROPAGATION_REQUIRES_NEW —— “特立独行”</h3>\n<ul>\n<li><strong>场景：</strong> 你在处理一个 <code>核心业务</code>（如用户下单），同时需要记录一份 <code>操作日志</code>。你希望无论下单成功与否，日志都必须成功记录。</li>\n<li><strong>行为：</strong> <code>REQUIRES_NEW</code> 会为 <code>createLog</code> 方法<strong>挂起</strong>当前事务（核心业务），然后<strong>开启一个全新的、独立的事务</strong>。新事务提交或回滚后，再恢复挂起的旧事务。两者之间没有任何关系。</li>\n</ul>\n<p>一句话总结： 我总要开新派对，不管你有没有派对。适用于与主业务解耦的辅助功能，如日志、邮件通知。</p>\n<h3><strong>3. <code>PROPAGATION_NESTED</code> —— “子母事务”</strong></h3>\n<ul>\n<li><p><strong>场景：</strong> 你在一个 <code>银行转账</code>（主事务）中，除了要扣减 A 账户、增加 B 账户外，还要进行一笔 <code>小额手续费</code> 的扣除。你希望手续费扣除失败可以回滚，但不影响转账主流程的成功。</p>\n</li>\n<li><p><strong>行为：</strong> <code>NESTED</code> 会在当前事务中设置一个<strong>保存点</strong>。如果嵌套事务失败，它会回滚到这个保存点，而不是回滚整个事务。如果主事务失败，那么所有嵌套事务都会一起回滚。</p>\n</li>\n<li><p><strong>与 <code>REQUIRES_NEW</code> 的区别：</strong></p>\n<ul>\n<li><code>REQUIRES_NEW</code> 是两个完全独立的事务，像两个独立的银行账户。</li>\n<li><code>NESTED</code> 是一个事务内的部分回滚，像一个大账户里的多个子记账，可以单独撤销某个子记账。</li>\n</ul>\n</li>\n<li><p><strong>注意：</strong> <code>NESTED</code> 依赖于底层数据库对保存点的支持（如 JDBC 的 <code>Savepoint</code>）</p>\n</li>\n</ul>\n<h2>属性二：<code>isolation</code> —— 隔离级别</h2>\n<p><strong><code>isolation</code>（隔离级别）</strong> 定义了多个并发事务之间的“社交距离”，以防止它们互相干扰导致数据错乱。它直接对应数据库的隔离级别。</p>\n<ul>\n<li><strong><code>Isolation.READ_UNCOMMITTED</code> (读未提交)：</strong> 能读到别人还没提交的“脏数据”。（几乎不用）</li>\n<li><strong><code>Isolation.READ_COMMITTED</code> (读已提交)：</strong> 只读取别人已经提交的数据。可以避免脏读，但可能出现“不可重复读”。</li>\n<li><strong><code>Isolation.REPEATABLE_READ</code> (可重复读)：</strong> 在同一个事务内多次读取同一数据，结果总是一样。可以避免脏读和不可重复读，但可能出现“幻读”。（<strong>MySQL 默认级别</strong>）</li>\n<li><strong><code>Isolation.SERIALIZABLE</code> (串行化)：</strong> 所有事务按顺序排队执行，完全隔离。性能最低。</li>\n</ul>\n<blockquote>\n<p>99% 的情况下，使用数据库的默认隔离级别就足够了。不要随意修改，除非你非常清楚自己在做什么，以及为什么需要这么做。</p>\n</blockquote>\n<h2>属性三：readOnly —— 只读模式</h2>\n<ul>\n<li><strong>作用：</strong> 告诉 Spring：“这个方法只负责查询数据，绝不修改任何数据”。</li>\n<li><strong>好处：</strong><ol>\n<li><strong>性能优化：</strong> Spring 会据此优化数据库连接。比如，可能会将事务设置为只读，让数据库驱动可以进行一些特定的优化。</li>\n<li><strong>代码清晰：</strong> 这是一个非常明确的信号，告诉所有开发者这个方法的意图是查询。</li>\n</ol>\n</li>\n</ul>\n<h2>属性四：<code>rollbackFor</code> &amp; <code>noRollbackFor</code> —— 异常回滚</h2>\n<p>Spring 默认的回滚策略可能和你想的并不一样。</p>\n<ul>\n<li><p><strong>痛点引入：</strong> “我的方法里抛了异常，为什么数据没有回滚？！”</p>\n</li>\n<li><p><strong>Spring 默认规则：</strong> Spring 认为，只有不可预期的运行时异常（<code>RuntimeException</code>）或错误（<code>Error</code>）才应该触发回滚。对于那些可以预期的、在编译期就需要处理的<strong>受检异常</strong>（Checked Exception，如 <code>IOException</code>, <code>SQLException</code>），它默认不回滚。</p>\n<ul>\n<li>为什么这么设计？因为 Spring 的设计者认为，受检异常通常是业务逻辑的一部分，你可能希望在代码中捕获并处理它，而不是直接让整个事务失败。</li>\n</ul>\n</li>\n<li><p><strong><code>rollbackFor</code> (回滚白名单)：</strong> 指定哪些异常需要回滚。</p>\n</li>\n</ul>\n<pre><code class=\"language-java\">// 当抛出任何 Exception (包括受检异常) 时都回滚\n@Transactional(rollbackFor = Exception.class)\npublic void methodWithCheckedException() throws IOException {\n    // ... 业务逻辑 ...\n    throw new IOException(&quot;文件操作失败&quot;); // 现在事务会回滚\n}\n</code></pre>\n<ul>\n<li><strong><code>noRollbackFor</code> (回滚黑名单)：</strong> 指定哪些异常<strong>不</strong>需要回滚。</li>\n</ul>\n<pre><code class=\"language-java\">// 即使是 RuntimeException，指定了也不回滚\n@Transactional(noRollbackFor = IllegalArgumentException.class)\npublic void methodWithSpecificException() {\n    throw new IllegalArgumentException(&quot;参数非法&quot;); // 事务不会回滚\n}\n</code></pre>\n<hr>\n<h1>常见的“事务失效”问题</h1>\n<ol>\n<li>方法权限问题。<code>@Transactional</code> 只能用于 <code>public</code> 方法。</li>\n<li><code>self-invocation</code>（自调用）问题。** （<strong>重点！</strong>）<ul>\n<li><strong>场景：</strong> 一个类中的 <code>methodA</code>（无注解）调用了同一个类中的 <code>methodB</code>（有 <code>@Transactional</code> 注解）。</li>\n<li><strong>原因：</strong> Spring AOP 是通过代理实现的。<code>methodA</code> 内部调用 <code>methodB</code> 时，走的是 <code>this</code> 引用，而不是代理对象，因此事务切面不会生效。</li>\n<li><strong>解决方案：</strong> （1）注入自己；（2）通过 <code>AopContext</code> 获取代理对象；（3）将 <code>methodB</code> 移到另一个 Service 中。</li>\n</ul>\n</li>\n<li>异常被 <code>try-catch</code> “吃掉”了。**<ul>\n<li><strong>场景：</strong> 在事务方法内部 <code>try-catch</code> 了异常，但没有在 <code>catch</code> 块中重新抛出。</li>\n<li><strong>原因：</strong> AOP 代理捕获不到异常，认为方法正常执行完毕，于是提交事务。</li>\n<li><strong>解决方案：</strong> 在 <code>catch</code> 中 <code>throw new RuntimeException();</code> 或手动设置事务状态 <code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</code>。</li>\n</ul>\n</li>\n<li>事务传播行为配置错误。** （回顾第三关的  <code>propagation</code>）</li>\n</ol>\n<hr>\n<h1>Spring编程式事务</h1>\n<p>当声明式事务无法满足复杂业务逻辑时，编程式事务成为必要选择。包括：</p>\n<ul>\n<li>一个方法中需要多个独立事务（部分提交、部分回滚）</li>\n<li>需要根据运行时条件动态决定事务边界</li>\n<li>需要在事务中执行非事务性操作</li>\n</ul>\n<p>代码示例：</p>\n<pre><code class=\"language-java\">@Service\npublic class OrderService {\n    \n    @Autowired\n    private TransactionTemplate transactionTemplate;\n    \n    public void placeOrder(Order order) {\n        // 第一个事务：创建订单\n        transactionTemplate.execute(status -&gt; {\n            try {\n                orderRepository.save(order);\n                // 其他订单相关操作\n                return true;\n            } catch (Exception e) {\n                status.setRollbackOnly();\n                return false;\n            }\n        });\n        \n        // 第二个事务：扣减库存\n        transactionTemplate.execute(status -&gt; {\n            try {\n                inventoryService.reduceStock(order.getProductId(), order.getQuantity());\n                return true;\n            } catch (InsufficientStockException e) {\n                status.setRollbackOnly();\n                // 可以在这里执行补偿逻辑\n                return false;\n            }\n        });\n    }\n}\n</code></pre>\n<p> 使用 PlatformTransactionManager（更底层的方式）</p>\n<pre><code class=\"language-java\">@Service\npublic class PaymentService {\n    \n    @Autowired\n    private PlatformTransactionManager transactionManager;\n    \n    public void processPayment(Payment payment) {\n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);\n        def.setTimeout(30); // 30秒超时\n        \n        TransactionStatus status = transactionManager.getTransaction(def);\n        \n        try {\n            paymentRepository.save(payment);\n            accountService.debit(payment.getAccountId(), payment.getAmount());\n            transactionManager.commit(status);\n        } catch (Exception e) {\n            transactionManager.rollback(status);\n            throw new PaymentException(&quot;Payment failed&quot;, e);\n        }\n    }\n}\n</code></pre>\n<h2>核心组件</h2>\n<p>Spring 事务管理的三大核心接口：</p>\n<ol>\n<li><strong>PlatformTransactionManager</strong>：事务管理器接口<ul>\n<li>负责事务的获取、提交和回滚</li>\n<li>常见实现：<code>DataSourceTransactionManager</code>、<code>JpaTransactionManager</code>等</li>\n</ul>\n</li>\n<li><strong>TransactionDefinition</strong>：事务定义信息<ul>\n<li>定义事务的传播行为、隔离级别、超时时间、只读状态等</li>\n<li>通过 <code>TransactionAttribute</code> 接口扩展</li>\n</ul>\n</li>\n<li><strong>TransactionStatus</strong>：事务状态<ul>\n<li>表示当前事务的状态（是否新事务、是否已完成、是否设置回滚等）</li>\n<li>提供控制事务的方法（如 <code>setRollbackOnly()</code>）</li>\n</ul>\n</li>\n</ol>\n",
  "published": true
}